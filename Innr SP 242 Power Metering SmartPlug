/**
 *  MIT License
 *  Copyright 2023 Jonathan Bradshaw (jb@nrgup.net)
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the 'Software'), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 *    This software was created by Jonathan Bradshaw for a smart plug / outlet by 
 *    manufacturer: 'Third Reality, Inc' (model: '3RSP02028BZ'), but it has been edited and
 *    amended by jellygreen, on the same copyright basis, to enable it to be
 *    used on HUBITAT hubs with an innr SP 242 smart plug /outlet with power monitoring.  
 *    Frequency measurements have not been implemented on this device, so that has been disabled.  
 *    For the moment there is no Firmware updating
 * 
 *    When switch turns on or off or toggles - all measured values are refreshed - voltage, amperage, power and energy
 *    Voltage, Amperage and Power can be set to report periodically and / or when values change by a threshold delta
 *    Energy only reports periodically (and is read by a refresh when switch turns on or off) - it does not report if periodic reporting is disabled whatever delta is set
 *                 - this periodic reporting appears to cease after the device is switched 'off' and resume when switched 'on'
 *    Energy resolution can be set to limit or increase the number of Energy Eventswith a value change
 *    Healthcheck pings for a report of energy consumed at a set period of silence from the device  - 0 is disabled; this continues if the device switch state is 'off'
 *    onTime4001 and offWait4002 are as per as per the zigbee cluster 0x006 spec for count down of on and and locked off times  
 *    a number of bugs fixed esp with timed on and off and setting up the initial values
 */

import groovy.transform.Field
import hubitat.zigbee.zcl.DataType
import java.math.RoundingMode

metadata {
    definition(name: 'Innr SP 242 Power Metering SmartPlug', version: '1.2.8', namespace: 'jellygreen', author: 'Jonathan Bradshaw - edited by jellygreen', singleThreaded: true) {
        
        capability 'Actuator'
        capability 'Configuration'
        capability 'CurrentMeter'
        capability 'EnergyMeter'
        capability "Initialize"
        capability 'Outlet'
        capability 'PowerMeter'
        capability 'Refresh'
        capability 'Sensor'
        capability 'Switch'
        capability 'VoltageMeasurement'
        capability 'HealthCheck'

        command 'toggle'
        // command 'installed'
        command 'onePressSetup', [[name:"Preferences first then One Press Setup, wait for 10 seconds then reload the page", description: "Press, wait for 10 seconds then reload the page" ] ] //
        command "onWithTimedOff"
        command "setOnTime", [[name:"Set On Time", type: "NUMBER", description: "Time in seconds that the switch will stay on after an on-with-timed-off command - max 6553sec = 1hr 49min" ] ] //
        command "setOffWait", [[name:"Set Off Wait Time", type: "NUMBER", description: "Time in seconds that the switch will stay off after the end of an on-with-timed-off command- max 6553sec = 1hr 49min" ] ] //
        command "setPerformOnWithTimedOff", [[name:"Set perform an onWithTimedOff command always or onlyIfSwitchIsOn", type: "ENUM", constraints:["always", "onlyIfSwitchIsOn"]]] //
        command "setPowerRestoreMode" , [[name:"powerRestoreMode", type: "ENUM", constraints:["Off", "On", "Last State"]]]
        // command "timedOnOffRefresh"  // refresh some 0x0006 cluster 4000 attributes 
        command "setHeathCheckInterval", [[name:"Set healthCheckInterval", type: "NUMBER", description: "Enter time in minutes, max 59"]]
        command "debugFor30Min", [[name:"Debug Log On for 30 Min", description: "Turn on debug logging for 30 min" ] ] //
        command "ReadReportingConfigs"
        
        attribute "onTime4001", "number"                    //0x0006, 0x4001 r u16
        attribute "offWait4002", "number"                   //0x0006, 0x4002 r u16
        attribute "performOnWithTimedOff", "string"
        attribute "powerRestoreState4003", 'enum', [ 'Off', 'On', 'Last State' ] // "string"         // 0x0006 0x4003
        attribute 'healthStatus', 'enum', [ 'unknown', 'offline', 'online', 'disabled' ]
        attribute 'healthCheckInterval', "number"           // 
        attribute 'powerFactor', 'number'                   // calculated, not read
        attribute 'energyLastRead', 'string'   // date and time of last energy report from the device - via periodic or healthcheck or refresh
        attribute "reportingEnergy", "string"  // 0.01 kWh - general zigbee reporting configuration format [min seconds between consecutive reports, maximum seconds between reports, subject to time restraints the minimum change / delta that triggers a report]
        attribute "reportingAmps", "string"    // 0.001 A - general zigbee reporting configuration format
        attribute "reportingVoltage", "string" // 0.1 V - general zigbee reporting configuration format
        attribute "reportingPower", "string"   // 1 W - general zigbee reporting configuration format      
        attribute "reportingOnOff", "string"   // switch - on / off general zigbee reporting configuration format
        attribute "reportingOnTime", "string"  // 4001
        attribute "reportingOffWait", "string" // 4002

        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0008,1000,0702,0B04,E001", outClusters:"000A,0019", model:"SP 242", manufacturer:"innr"
    }

/**
innr manufacturer code is 0x1166  add in readattribute command as [mfgCode:0x1166]
#define ZBEE_HA_DEVICE_ON_OFF_PLUG_IN_UNIT              0x010A
**/
    
    
    preferences {

        input name: 'disableOnOff', type: 'bool', title: '<b>Disable Power Commands</b>', defaultValue: false, description: '<i>Disables the driver power commands to stop accidental changes.</i>'

        input name: 'powerDelta', type: 'number', title: '<b>Power Minimum Change</b>', defaultValue: 10, description:'<i>The minimum power change Watts that device will report, range is 1 to 1000, default is 10 (10W).</i>', range:'1..1000'

        input name: 'amperageDelta', type: 'number', title: '<b>Amperage Minimum Change - mA</b>', defaultValue: 100, description: '<i>The minimum amperage change (in milliAmps, mA) that will be recorded, range is 5 to 1000, default is 100 (100mA, 0.1A).</i>', range: '5..1000'

        input name: 'voltageDelta', type: 'number', title: '<b>Voltage Minimum Change</b>', defaultValue: 5, description:'<i>The minimum voltage change V that will be recorded, range is 1 to 100, default is 5 (5V), .</i>', range: '1..100'
        
        input name: 'periodicReportingOnOff', type: 'bool', title:'<b>Enable Voltage, Amperage and Power Periodic Reporting</b>', defaultValue: false, description:'on, adds periodic reporting to change based reporting from the device'
        
        input name: 'periodicReportingPeriod', type: 'number', title: '<b>Voltage, Amperage and Power Reporting Period in Seconds</b>', defaultValue: 3600, description:'periodic reporting period in seconds, default and minimum is one hour, 3600s', range:'360..43200'

        input name: 'energyPeriodicReportingOnOff', type: 'bool', title:'<b>Enable Energy Periodic Reporting</b>', defaultValue: true, description:'on, adds energy periodic reporting from the device'
        
        input name: 'energyReportingPeriod', type: 'number', title: '<b>Energy Reporting Period</b>', defaultValue: 3600, description:'<i>The energy reporting period in seconds, default is 3600 (1 hour), range 360s (6 min) to 43200s (12 hours).</i>', range: '360..43200'

        input name: 'energyResolution', type: 'enum', title: '<b>Energy Reporting Resolution</b>', options: EnergyResolutionOpts.options, defaultValue: EnergyResolutionOpts.defaultValue, description:'<i>The energy reporting resolution, 0 is 1kWh, 1 is 0.1kWh, 2 is 0.01kWh, default is 2</i>'
        
        input name: 'infoLogging', type: 'bool', title: '<b>Enable descriptionText logging</b>', defaultValue: true, description: '<i>Enables command logging.</i>'

        input name: 'debugLogging', type: 'bool', title: '<b>Enable debug logging</b>', defaultValue: false, description:'<i>Turns on debug logging for 30 minutes.</i>'
        
        input name: 'traceLogging', type: 'bool', title: '<b>Enable trace logging</b>', defaultValue: false, description:'<i>Turns on trace logging for 30 minutes.</i>'
    }
}

@Field static final String VERSION = '1.2.8 (2024-03-02)'

void installed() {    //Invoked by Hubitat when driver is installed
    onePressSetup()
    state.driverInstalledDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
    if (infoLogging) log.info "${device.displayName} installed by JellyGreen's driver" 
    return
}

def onePressSetup(){
    debugFor30Min()
    initialize()
    updated()
    runIn(1, 'configure')
    runIn(5, 'refresh') 
    runIn(7, 'timedOnOffRefresh') 
    if (infoLogging) log.info "${device.displayName} onePressSetup - done"
}

def initialize(){
    // state.clear()
    // settings.clear()
    setHeathCheckInterval(45)
    cmds = setPowerRestoreMode("Last State")
    device.updateSetting('energyResolution', [value: 2, type: 'number' ])
    device.updateSetting('energyReportingPeriod', [value: 3600, type: 'number' ])
    sendEvent(name: "performOnWithTimedOff",  unit: null, value: "always", type: STRING, descriptionText: "performOnWithTimedOff") // set default value
    state.driverInitializedDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
    if (infoLogging) log.info "JellyGreen's driver for ${device.displayName} initialized"
	return cmds     // initializeCommands
}

def configure() {             // configure attribute reporting min period, max period and delta
    def int reportingPeriod = settings.periodicReportingPeriod
    def int energyReportingPeriod = settings.energyReportingPeriod ?: 3600
    if (settings.periodicReportingOnOff == false) reportingPeriod = 0
    if (settings.energyReportingPeriodOnOff == false) energyReportingPeriod = 0    
    def int powerDelta = settings.powerDelta            // try 1 which should give a min delta of 1W
    def int voltageDelta = settings.voltageDelta * 10   // try no factor which should give delta of 1V    
    def int amperageDelta = settings.amperageDelta      // no multiplier needed, as value is milliamps, mA
    def int energyDelta = 1                             // ? is there is energy reporting on this device 1 is 0.01kWh
    if (settings.energyResolution == null) {device.updateSetting('energyResolution', [value: 2, type: 'number' ])}
    if (settings.energyResolution == 2) {energyDelta = 1}
    if (settings.energyResolution == 1) {energyDelta = 10}
    if (settings.energyResolution == 0) {energyDelta = 100}
    List<String> cmds = []
    cmds += zigbee.configureReporting(zigbee.ON_OFF_CLUSTER, POWER_ON_OFF_ID, DataType.BOOLEAN, 0, reportingPeriod, null, [:], DELAY_MS)    // switch state was null 
    cmds += zigbee.configureReporting(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, ACTIVE_POWER_ID, DataType.INT16, 0, reportingPeriod, powerDelta, [:], DELAY_MS)    //power reporting - min change in W was 10
    cmds += zigbee.configureReporting(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, RMS_VOLTAGE_ID, DataType.UINT16, 0, reportingPeriod, voltageDelta, [:], DELAY_MS)    //voltage reporting - min change in volts was 10
    cmds += zigbee.configureReporting(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, RMS_CURRENT_ID, DataType.UINT16, 0, reportingPeriod, amperageDelta, [:], DELAY_MS)    //current reporting  - min change in mA was 100
    cmds += zigbee.configureReporting(zigbee.METERING_CLUSTER, ATTRIBUTE_READING_INFO_SET, DataType.UINT48, 0, energyReportingPeriod, energyDelta,[mfgCode:0x1166], DELAY_MS)  //, [:], DELAY_MS)      // ? no energy reporting on this device // min change in Wh was 10 // DataType.UINT48 is 0x25
    // cmds += zigbee.configureReporting(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, AC_FREQUENCY_ID, DataType.UINT16, 0, 240, 10, [:], DELAY_MS)
    cmds += zigbee.configureReporting(0x0006, 0x4001, 0x21, 5, 43200, 5, [:], DELAY_MS)    //  onTime4001
    cmds += zigbee.configureReporting(0x0006, 0x4002, 0x21, 5, 43200, 5, [:], DELAY_MS)    //  offWait4002   
    if (debugLogging) log.debug "Configure Reporting commands sent for 7 attributes"
    state.driverConfiguredDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
    runIn (3, 'ReadReportingConfigs')
    return cmds
}

def ReadReportingConfigs(){
    def cmds = []
        cmds += zigbee.reportingConfiguration(zigbee.ON_OFF_CLUSTER, POWER_ON_OFF_ID, [:], DELAY_MS) // ON OFF Cluster 0x0006 attribute 0x0000
        cmds += zigbee.reportingConfiguration(zigbee.ON_OFF_CLUSTER, 0x4001, [:], DELAY_MS) // ON OFF Cluster 0x0006 attribute 0x4001 OnTime   
        cmds += zigbee.reportingConfiguration(zigbee.ON_OFF_CLUSTER, 0x4002, [:], DELAY_MS) // ON OFF Cluster 0x0006 attribute 0x4002 OffWait    
        cmds += zigbee.reportingConfiguration(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, 0x0505, [:], DELAY_MS) // Voltage cluster 0x0B04 attribute 0505
        cmds += zigbee.reportingConfiguration(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, 0x0508, [:], DELAY_MS) // Amperage cluster 0x0B04 attribute 0508
        cmds += zigbee.reportingConfiguration(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, 0x050B, [:], DELAY_MS) // Power cluster 0x0B04 attribute 050B
        cmds += zigbee.reportingConfiguration(zigbee.METERING_CLUSTER, 0x0000, [:], DELAY_MS) // Energy cluster 0x0702 attribute 0x0000
        if (debugLogging) log.debug "Read Reporting Configuration request sent for 7 reportable attributes"
		return cmds 
}

def refresh() {    //  Refresh Command
    def refreshCommands = []
    refreshCommands += zigbee.readAttribute(zigbee.ON_OFF_CLUSTER, POWER_ON_OFF_ID, [:], DELAY_MS)                           // Get switch On/Off state
    scheduleCommandTimeoutCheck()
    if (debugLogging) log.debug "Read Attribute requested for 1 item - switch state"
    state.driverRefreshedDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
	return refreshCommands                     // delayBetween(refreshCommands,20)
}    

def refreshMeters() {    //  Refresh Command
    def refreshMetersCommands = []
    refreshMetersCommands += zigbee.readAttribute(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, [RMS_CURRENT_ID], [:], DELAY_MS)          // Get ampage and power measurements
    refreshMetersCommands += zigbee.readAttribute(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, [RMS_VOLTAGE_ID], [:], DELAY_MS)          // Get voltage measurements
    refreshMetersCommands += zigbee.readAttribute(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, [ACTIVE_POWER_ID], [:], DELAY_MS)         // Get power measurements
            // AC_FREQUENCY_ID, // no frequency reporting on this device
    refreshMetersCommands += zigbee.readAttribute(zigbee.METERING_CLUSTER, ATTRIBUTE_READING_INFO_SET, [:], DELAY_MS) // DELAY_MS) // Get energy measurement
    scheduleCommandTimeoutCheck()
	return refreshMetersCommands                     // delayBetween(refreshCommands,20)
}


def timedOnOffRefresh() {    // Get: onTime4001; offWait4002;  powerRestoreState4003

    def refreshCommands = []
    refreshCommands +=  zigbee.readAttribute(0x0006, 0x4001, [:], DELAY_MS)                 // OnTime uint16 0x0000 – 0xffff Read Write 0x0000 O = but reports read only
    refreshCommands +=  zigbee.readAttribute(0x0006, 0x4002, [:], DELAY_MS)                 // OffWaitTime uint16 0x0000 – 0xffff Read Write 0x0000 O = but reports read only
    refreshCommands +=  zigbee.readAttribute(0x0006, 0x4003, [:], DELAY_MS)  // , [mfgCode:0x1166]  // powerOn  innr
    if (debugLogging) log.debug "Read Attribute requested for 3 items"
	return refreshCommands
}  

def setPowerRestoreMode(powerRestoreMode){
    if (powerRestoreMode == "Off") {thisValue = 00}
    if (powerRestoreMode == "On") {thisValue = 0x01}
    if (powerRestoreMode == "Last State") {thisValue = 0xFF}
    def cmds = []
    cmds += zigbee.writeAttribute(0x0006, 0x4003, 0x30, thisValue, [mfgCode:0x1166], DELAY_MS) 
    cmds += zigbee.readAttribute (0x0006, 0x4003)
    if (debugLogging) log.debug "Write / Read Attribute requested for 1 item"
    return cmds 
}

def setHeathCheckInterval(rawInterval){
    int interval = (rawInterval as Integer) ?: 0
    if (interval > 59) interval = 59
    if (interval < 0) interval = 0
    sendEvent(name: "healthCheckInterval",  unit: null, value: interval, type: null, descriptionText: "healthCheckInterval set")
    if (interval > 0)
        {
        if (infoLogging) log.info "${device} scheduling health check every ${interval} minutes"
        sendEvent(name: "healthStatus",  unit: null, value: "unknown", type: null, descriptionText: "healthStatus attribute unknown while awaited")
        scheduleDeviceHealthCheck(interval)
        runIn (2,'ping')
        }
    else
        {
        unschedule('deviceCommandTimeout')
        sendEvent(name: "healthStatus",  unit: null, value: "disabled", type: null, descriptionText: "healthStatus attribute disabled")   
        }
}

def updated() {         // Invoked by Hubitat when the driver configuration is updated
     unschedule()
    if (debugLogging) {
        log.debug settings
        runIn(1800, 'debuglogsOff')
    }
    if (traceLogging) {
        log.trace settings
        runIn(1800, 'tracelogsOff')
    }
    configure()
    runIn(4, 'refresh')
    runIn(6, 'timedOnOffRefresh')
    state.driverUpdatedDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
}

void debugFor30Min(){
    device.updateSetting('debugLogging', [value: 'true', type: 'bool']) 
    unschedule(debuglogsOff)
    log.debug "debug logging turned on for 30 minutes"
    runIn(1800, 'debuglogsOff')

}

void debuglogsOff() {    //  Disable logging (for debugging)
    log.warn "${device.displayName} debug logging disabled..."
    device.updateSetting('debugLogging', [value: 'false', type: 'bool'])
}

void tracelogsOff() {    //  Disable logging (for trace)
    log.warn "${device.displayName} trace logging disabled..."
    device.updateSetting('traceLogging', [value: 'false', type: 'bool'])
}

def deviceCommandTimeout() {    //Send health status event upon a timeout
    log.warn "${device.displayName} no response received (device offline?)"
    sendEvent(name: "healthStatus",  unit: null, value: "offline", type: null, descriptionText: "healthStatus attribute gone offline")
}

def ping() {    // Ping Command
    if (debugLogging) log.debug "${device.displayName} ping..."       // Using energy read METERING_CLUSTER attribute 0x00 as a simple ping/pong mechanism
    scheduleCommandTimeoutCheck()
    return    zigbee.readAttribute(zigbee.BASIC_CLUSTER, PING_ATTR_ID, [:], 0) // zigbee.readAttribute(zigbee.METERING_CLUSTER, ATTRIBUTE_READING_INFO_SET, [:], 0)    // was using info cluster for ping -
}

/**
def clearSchedule(){
    unschedule()   
}
**/

def on() {                                //     On Command
    if (settings.disableOnOff) { return [] }
    if (infoLogging) log.info "${device.displayName} turn on command"
    scheduleCommandTimeoutCheck()
    // runIn(1, 'refresh')
    def cmds =                                        //   
	zigbee.command(zigbee.ON_OFF_CLUSTER, 0x01, [:], DELAY_MS)+  //
    zigbee.readAttribute(0x0006, 0x0000) 
    return cmds
}

def off() {                                //    Off Command
    if (settings.disableOnOff) { return [] }
    if (infoLogging) log.info  "${device.displayName} turn off command" 
    scheduleCommandTimeoutCheck()
    def cmds =                                        //   
	zigbee.command(zigbee.ON_OFF_CLUSTER, 0x00, [:], DELAY_MS) +  //
    zigbee.readAttribute(0x0006, 0x0000) 
    return cmds
}

def toggle() {                             // Toggle Command (On/Off)
    if (settings.disableOnOff) { return [] }
    if (infoLogging) log.info "${device.displayName} toggle command"
    scheduleCommandTimeoutCheck()
    def cmds =                                        //   
	zigbee.command(zigbee.ON_OFF_CLUSTER, 0x02, [:], DELAY_MS)+  //
    zigbee.readAttribute(0x0006, 0x0000) 
    return cmds
}

def setOnTime(inputTime){
    if ((inputTime >= 0) && (inputTime <= 6553)){        // 0xfffe / multiply by 10 (for tenths of a second)
        int onTime = (Math.round(inputTime)) * 10
        def cmds =                                        //   
	    zigbee.writeAttribute(0x0006, 0x4001, 0x21, onTime) +  //
        zigbee.readAttribute(0x0006, 0x4001) 
        return delayBetween(cmds, 500)   
        }
    else {
        if (debugLogging) log.debug "Set On Time, inputTime is out of range"
        }
}

def setOffWait(inputTime){
    if ((inputTime >= 0) && (inputTime <= 6553)){        // 0xfffe / multiply by 10 (for tenths of a second)
    int offWait = (Math.round(inputTime)) * 10
    def cmds =                                        //   
	zigbee.writeAttribute(0x0006, 0x4002, 0x21, offWait) +
    zigbee.readAttribute(0x0006, 0x4002) //
    return delayBetween(cmds, 500)  
    }
    else {
    if (debugLogging) log.debug "Set Off Wait Time, inputTime is out of range"
    }
}

def setPerformOnWithTimedOff(selectedValue){
    def map = [:]
    map.name = "performOnWithTimedOff"
    map.descriptionText = "set by driver"    
    if (selectedValue == "always") {map.value = "always"}
    else if (selectedValue == "onlyIfSwitchIsOn") {map.value = "onlyIfSwitchIsOn"}
    sendEvent(name: map.name, value: map.value, descriptionText: map.descriptionText)
}

def onWithTimedOff() {                                            // int OnTimeField, int OffWaitTimeField
    if (traceLogging) log.trace "on with timed off method called"
    def String onOffControl  
    if (device.currentValue("performOnWithTimedOff") == "always") {onOffControl = "00"} // so processed unconditionally; if "01" command only works when the switch is already in the "on" / Accept Only When On}
    if (device.currentValue("performOnWithTimedOff") == "onlyIfSwitchIsOn") {onOffControl = "01"} // so command only works when the switch is already in the "on" state   
    
    int onTime = device.currentValue("onTime4001") * 10 // tenths of a seconds - 600 is one minute in hex 0x0258 then times 10
    def String payloadOnTime = zigbee.convertToHexString(onTime,4)
        payloadOnTime = zigbee.swapOctets(payloadOnTime)
    
        // if (debugLogging) log.debug "payloadOnTime: $payloadOnTime"
    
    int offWait = device.currentValue("offWait4002") * 10 // tenths of a seconds - 600 is one minute in hex 0x0258 then times 10
    def String payloadOffWaitTime = zigbee.convertToHexString(offWait,4)
        payloadOffWaitTime = zigbee.swapOctets(payloadOffWaitTime)

        // if (debugLogging) log.debug "payloadOffWaitTime: $payloadOffWaitTime"    
    
     def String payload = onOffControl+payloadOnTime+payloadOffWaitTime
 
            // if (debugLogging) log.debug "payload: $payload"
    
    def cmds =
            zigbee.command(0x0006, 0x42, [:], 0, payload) +  //write using cluster command - 2000 is a 2second delay  [mfgCode:0x1166] not needed set 2000 to zero
            zigbee.readAttribute(0x0006, 0x0000) 
            if (debugLogging) log.debug " tried to set an on period with a timed off period - my command is: $cmds"
		return delayBetween(cmds, 500)
}   
    
def parse(description) {                   // Parse Incoming Zigbee Message
    if (debugLogging) log.debug "message received by parse(): $description"
    def Map descMap = zigbee.parseDescriptionAsMap(description)
    if (debugLogging) log.debug "message as a map is: $descMap"
    
    if ((device.currentValue('healthStatus') != 'online') && (device.healthCheckInterval != 0))  {sendEvent(name: "healthStatus",  unit: null, value: "online", type: null, descriptionText: "healthStatus attribute gone online")}
    
    unschedule('deviceCommandTimeout')      // unschedule the device command response timeout 

    if ((descMap.isClusterSpecific != true) && (descMap.profileId != "0x0000")){      // ignore cluster specific messages and profile Id = 0000 parse everything else
        parseGeneralCommandResponse(descMap)
        }
    else if (debugLogging) log.debug "isClusterSpecific is true or profileID == 0000; ZDO Cluster information received and ignored" // generally appears to be a message identifier counter
    return
}
    
/**
 * Zigbee General Command Parsing
 * @param descMap Zigbee message in parsed map format
 */
def parseGeneralCommandResponse(descMap) {
    if (traceLogging) log.trace "parseGeneralCommandResponse() description: $descMap"    
    def int commandId = hexStrToUnsignedInt(descMap.command)
    switch (commandId) {
        case 0x01: // read attribute response
            parseClusterAttributeValue(descMap)
            break
        case 0x04: // write attribute response
            if (traceLogging) log.trace "parseWriteAttributeResponse() description: $descMap"       
            final String data = descMap.data in List ? ((List)descMap.data).first() : descMap.data
            final int statusCode = hexStrToUnsignedInt(data)
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${data}"
            
            if ((clusterInt == 0x006) && (statusName == "Success")) {
                log.debug "Refresh on Success" 
                refresh()
            }
            if (debugLogging) log.debug "${device} zigbee response write ${clusterLookup(descMap.clusterInt)} attribute response: ${statusName}"
            
        
            else if (statusCode > 0x00) log.warn "${device} zigbee response write ${clusterLookup(descMap.clusterInt)} attribute error: ${statusName}"
            break
        case 0x07: // configure reporting response
            final String status = ((List)descMap.data).first()
            final int statusCode = hexStrToUnsignedInt(status)
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${status}"        
            if (statusName == "Success"){
                if (debugLogging) log.debug "${device} zigbee configure reporting response: ${statusName} ${descMap.data}"  
            }
            else {log.warn "${device} zigbee configure reporting error: ${statusName} ${descMap}" }
            break
        case 0x09: // read reporting configuration response
            if (traceLogging) log.trace "parseReadReportingConfigResponse() description: $descMap"      
            final List<String> data = descMap.data as List<String>
            final String status = data.first()
            final int statusCode = hexStrToUnsignedInt(status)
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${status}"
            if (statusName != "Success") {
                if (debugLogging) log.debug "${device} zigbee read reporting configuration response:status is: $status; statusName is: ${statusName}, data is: ${descMap.data}, data[0] is:${data[0]}, data[1] is:${data[1]}, data[2] is:${data[2]},data[3] is:${data[3]}}"
                }
            if (data[1] != '00') {
                return
                }
    
            final String thisCluster = '0x' + descMap.clusterId
            final String attribute = '0x' + data[3] + data[2]
            final Integer dataType = hexStrToUnsignedInt(data[4])
            def Integer minReportingInterval
            def Integer maxReportingInterval
            if (!data[5]){return}
            else
            {
                minReportingInterval = (hexStrToUnsignedInt(data[6] + data[5]))
                maxReportingInterval = (hexStrToUnsignedInt(data[8] + data[7]))
            }
            def Integer reportableChange = null 
            if (!DataType.isDiscrete(dataType)) {
                final int start = DataType.getLength(dataType) + 8
                reportableChange = hexStrToUnsignedInt(data[start..9].join())
            }
            if (debugLogging) log.debug "${device} zigbee reporting configuration  [cluster: ${thisCluster}, attribute: ${attribute}, dataType: ${dataType}, minReportingInterval: ${minReportingInterval}, maxReportingInterval: ${maxReportingInterval}, reportableChange: ${reportableChange}]"
            def String thisString = "[min: ${minReportingInterval}, max: ${maxReportingInterval}, delta: ${reportableChange}]"
            if ((thisCluster == "0x0702") && (attribute == "0x0000")) {sendEvent(name: "reportingEnergy", value: thisString, unit: null, descriptionText: "energy reporting configuration")}
            if ((thisCluster == "0x0B04") && (attribute == "0x0505")) {sendEvent(name: "reportingVoltage", value: thisString, unit: null, descriptionText: "voltage reporting configuration")}
            if ((thisCluster == "0x0B04") && (attribute == "0x0508")) {sendEvent(name: "reportingAmps", value: thisString, unit: null, descriptionText: "amperage reporting configuration")}
            if ((thisCluster == "0x0B04") && (attribute == "0x050B")) {sendEvent(name: "reportingPower", value: thisString, unit: null, descriptionText: "power reporting configuration")}
            if ((thisCluster == "0x0006") && (attribute == "0x0000")) {sendEvent(name: "reportingOnOff", value: thisString, unit: null, descriptionText: "on/off reporting configuration")}
            if ((thisCluster == "0x0006") && (attribute == "0x4001")) {sendEvent(name: "reportingOnTime", value: thisString, unit: null, descriptionText: "onTime4001 reporting configuration")}
            if ((thisCluster == "0x0006") && (attribute == "0x4002")) {sendEvent(name: "reportingOffWait", value: thisString, unit: null, descriptionText: "offWait4002 reporting configuration")}
            break
        case 0x0A:  // report of an attribute
            parseClusterAttributeValue(descMap)
            break
        case 0x0B: // default command response
            if (traceLogging) log.trace "parseDefaultCommandResponse() description: $descMap"  
            final List<String> data = descMap.data as List<String>
            final String commandIdString = data[0]
            final int statusCode = hexStrToUnsignedInt(data[1])
            final String status = ZigbeeStatusEnum[statusCode] ?: "0x${data[1]}"
            if (statusCode > 0x00) {
                log.warn "${device} zigbee ${clusterLookup(descMap.clusterInt)} command 0x${commandIdString} error: ${status}"
                } 
            else if (debugLogging) {
                log.debug "${device} zigbee ${clusterLookup(descMap.clusterInt)} command 0x${commandIdString} response: ${status}"
            /**    
                if ((clusterLookup(descMap.clusterInt) =="ON_OFF_CLUSTER") && (commandIdString == "00") && (status == "Success")) {
                    sendEvent(name: "switch", unit: "", value: "off", type: null, descriptionText: 'switch attribute updated for successful 0x0006 00 off command')
                    //runIn(2, 'refreshMeters')
                    }
                else if ((clusterLookup(descMap.clusterInt) =="ON_OFF_CLUSTER") && (commandIdString == "01") && (status == "Success")) {
                    sendEvent(name: "switch", unit: "", value: "on", type: null, descriptionText: 'switch attribute updated for successful 0x0006 01 on command')
                    //runIn(2, 'refreshMeters')
                    }
                else if ((clusterLookup(descMap.clusterInt) =="ON_OFF_CLUSTER") && (commandIdString == "02") && (status == "Success")) {
                   // if (device.currentValue("switch") == "on")  sendEvent(name: "switch", unit: "", value: "off", type: null, descriptionText: 'switch attribute updated for successful 0x0006 02 toggle to off command')
                   // else sendEvent(name: "switch", unit: "", value: "on", type: null, descriptionText: 'switch attribute updated for successful 0x0006 02 toggle to on command')
                    // runIn(2, 'refreshMeters')
                    }
            **/
            }
            break
        default:
            final String commandName = ZigbeeGeneralCommandEnum[commandId] ?: "Not a programmed zigbee response command, command: (0x${descMap.command})"
            final String clusterName = clusterLookup(descMap.clusterInt)
            final String status = descMap.data in List ? ((List)descMap.data).last() : descMap.data
            final int statusCode = hexStrToUnsignedInt(status)
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${status}"
            if (statusCode > 0x00) {
                log.warn "${device} zigbee ${commandName} ${clusterName} error: ${statusName}"
            } else if (debugLogging) {
                log.debug "${device} zigbee ${commandName} ${clusterName}: ${descMap.data}"
            }
            break
    }
}


def parseClusterAttributeValue(descMap){    
    if (debugLogging) {
        final String clusterName = clusterLookup(descMap.clusterInt)
        final String attribute = descMap.attrId ? " attribute 0x${descMap.attrId} (value ${descMap.value})" : 'but with no attribute in this message'
        log.debug "${device} zigbee message received regarding ${clusterName} " + attribute }
    switch (descMap.clusterInt as Integer) {
        case zigbee.BASIC_CLUSTER:
            parseBasicCluster(descMap)
            descMap.remove('additionalAttrs')?.each { final Map map -> parseBasicCluster(descMap + map) }
            break
        case zigbee.ELECTRICAL_MEASUREMENT_CLUSTER:
            //if (state.constantsMultDiv == null) { state.constantsMultDiv = [:] }
            //if (state.values == null) { state.values = [:] }
            parseElectricalMeasureCluster(descMap)
            descMap.remove('additionalAttrs')?.each { final Map map -> parseElectricalMeasureCluster(descMap + map) }
            break
        case zigbee.METERING_CLUSTER:
            //if (state.values == null) { state.values = [:] }
            parseMeteringCluster(descMap)
            descMap.remove('additionalAttrs')?.each { final Map map -> parseMeteringCluster(descMap + map) }
            break
        case zigbee.ON_OFF_CLUSTER:
            parseOnOffCluster(descMap)
            descMap.remove('additionalAttrs')?.each { final Map map -> parseOnOffCluster(descMap + map) }
            break
        default:
            if (debugLogging) {
                log.debug "in parse () default of switch on clusterInt:  message: ${descMap}"
            }
            break
    }
}


/**
 * Zigbee Basic Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseBasicCluster(final Map descMap) {
        if (traceLogging) log.trace "parseBasicCluster() description: $descMap"
    switch (descMap.attrInt as Integer) {
        case PING_ATTR_ID:  // PING_ATTR_ID: // Using 0x01 read as a simple ping/pong mechanism - 
            if (debugLogging) { log.debug 'pong..' }
            break
        case FIRMWARE_VERSION_ID:
            final String version = descMap.value ?: 'unknown'
            if (infoLogging) log.info "${device} device firmware version is ${version}"
            updateDataValue('softwareBuild', version)
            break
        default:
            log.warn "${device} zigbee received unknown Basic cluster attribute 0x${descMap.attrId} (value ${descMap.value})"
            break
    }
}

/**
 * Zigbee Electrical Measurement Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseElectricalMeasureCluster(final Map descMap) {
    if (traceLogging) log.trace "parseElectricalMeasureCluster() description: $descMap"
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value
    final long value = hexStrToUnsignedInt(descMap.value)
    switch (descMap.attrInt as Integer) {
        case AC_CURRENT_DIVISOR_ID:
        case AC_CURRENT_MULTIPLIER_ID:
        case AC_POWER_DIVISOR_ID:
        case AC_POWER_MULTIPLIER_ID:
        case AC_VOLTAGE_DIVISOR_ID:
        case AC_VOLTAGE_MULTIPLIER_ID:
            readConstantsMultDiv[descMap.attrInt as String] = value
            break
        case AC_FREQUENCY_ID:
            // updateAttribute('frequency', value, 'Hz', 'physical')
            break
        case RMS_CURRENT_ID:
            handleRmsCurrentValue(value)
            break
        case ACTIVE_POWER_ID:
            handleActivePowerValue(value)
            break
        case RMS_VOLTAGE_ID:
            handleRmsVoltageValue(value)
            break
        default:
            log.warn "${device} zigbee received unknown Electrical Measurement cluster attribute 0x${descMap.attrId} (value ${descMap.value})"
            break
    }
}

/**
 * Handle RMS Current Value updates
 * @param value The new RMS Current Value
 */
void handleRmsCurrentValue(final long value) {  //Amperage value stored on the device is in mA - multiplier is 1 and divisor is 1000
    final Integer multiplier = 1 //  constantsMultDiv[AC_CURRENT_MULTIPLIER_ID as String] as Integer
    final Integer divisor = 1000 // constantsMultDiv[AC_CURRENT_DIVISOR_ID as String] as Integer
    if (multiplier > 0 && divisor > 0) {
        final BigDecimal lastValue = 0 // state.values[RMS_CURRENT_ID as String] as BigDecimal
        BigDecimal result = value * multiplier / divisor
        result = result.setScale(3, RoundingMode.HALF_UP)
        sendEvent(name: "amperage",  unit: "A", value: result, type: null, descriptionText: "amperage attribute updated")
        if ((result == 0)) 
            {
            sendEvent(name: "powerFactor", unit: "", value: 0.0, type: type, descriptionText: "set to zero if current is zero")
            sendEvent(name: "power", unit: "W", value: 0, type: type, descriptionText: "set to zero if current is zero")
            }       
        else
            {
            updatePowerFactor()
            }
    }
}

/**
 * Handle Active Power Value updates
 * @param value The new Power Value
 */
void handleActivePowerValue(final long value) {      //Power value stored on the device is in Watts - multiplier is 1 and divisor is 1
    final Integer multiplier = 1                     // constantsMultDiv[AC_POWER_MULTIPLIER_ID as String] as Integer
    final Integer divisor = 1                        // constantsMultDiv[AC_POWER_DIVISOR_ID as String] as Integer
    if (multiplier > 0 && divisor > 0) {
        final BigDecimal lastValue = 0               //state.values[ACTIVE_POWER_ID as String] as BigDecimal
        BigDecimal result = (int)value * multiplier / divisor
        result = result.setScale(0, RoundingMode.HALF_UP)  // was 1
        sendEvent(name: "power",  unit: "W", value: result, type: null, descriptionText: "power attribute updated")
        updatePowerFactor()
        }
}

/**
 * Handle RMS Voltage Value updates
 * @param value The new Voltage Value
 */
void handleRmsVoltageValue(final long value) {    //Voltage value stored on the device is in volts - multiplier is 1 and divisor is 1
    final Integer multiplier = 1 //constantsMultDiv[AC_VOLTAGE_MULTIPLIER_ID as String] as Integer
    final Integer divisor = 1 // constantsMultDiv[AC_VOLTAGE_DIVISOR_ID as String] as Integer
    if (multiplier > 0 && divisor > 0) {
        final BigDecimal lastValue = 0 // state.values[RMS_VOLTAGE_ID as String] as BigDecimal
        BigDecimal result = value * multiplier / divisor
        result = result.setScale(0, RoundingMode.HALF_UP)
        sendEvent(name: "voltage",  unit: "V", value: result, type: null, descriptionText: "voltage attribute updated")
        updatePowerFactor()
    }
}

/**
 * Zigbee Metering Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseMeteringCluster(final Map descMap) {        // ClusterId 0x0702
    if (traceLogging) log.trace "parseMeteringCluster() description: $descMap"      
    if (descMap.value == null || descMap.value == 'FFFF') 
    {       // invalid or unknown value
            if (debugLogging) log.debug "descMap. value is null or value is FFFF"
            return
    } 
    final long value = hexStrToUnsignedInt(descMap.value)
    //if (debugLogging) log.debug "value is $value"
    switch (descMap.attrInt as Integer) {
        case ATTRIBUTE_READING_INFO_SET:        // once used this read as a simple ping/pong mechanism
            // if (debugLogging) { log.debug 'pong..kWh' }
            final Long divisor = 100 // put 100 in here to see as METERING_DIVISOR_ID fails as no attribute used to say ... //  constantsMultDiv[METERING_DIVISOR_ID as String] as Long
            final BigDecimal currentValue = 0 // state.values[ATTRIBUTE_READING_INFO_SET as String] as BigDecimal  // put 0 in here to see // 
            if (divisor > 0) {
                BigDecimal result = value / divisor
//                if (debugLogging) log.debug "energyResolution = ${settings.energyResolution} or as an integer ${(settings.energyResolution as Integer)}"
                def int energyResolution = (settings.energyResolution as Integer)
//                if ((energyResolution < 0) || (energyResolution > 1)) {energyResolution = 2}
                result = result.setScale(energyResolution, RoundingMode.HALF_UP)
                final String unit = "kWh" // constantsMultDiv[METERING_UNIT_OF_MEASURE_ID as String] == 0 ? 'kWh' : '' // "kWh" // put kWh to see //
                def String energyLastReadDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
                sendEvent(name: "energyLastRead",  unit: null, value: energyLastReadDateTime, type: null, descriptionText: "energy was read on Date / Time")
                sendEvent(name: "energy",  unit: "kWh", value: result, type: null, descriptionText: "energy attribute updated")
             }
            break
        case METERING_DIVISOR_ID:
        case METERING_UNIT_OF_MEASURE_ID:
        case METERING_SUMMATION_FORMATTING_ID:
            //readConstantsMultDiv[descMap.attrInt as String] = value
            break
        default:
            log.warn "${device} zigbee received unknown Metering cluster attribute 0x${descMap.attrId} (value ${descMap.value})"
            break
    }
}

/**
 * Zigbee On Off Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseOnOffCluster(final Map descMap) {
    if (traceLogging) log.trace "parseOnOffCluster() description: $descMap" 
    def Integer value
    switch (descMap.attrInt as Integer) {
        case POWER_ON_OFF_ID:    // 0x0000
            def thisValue = descMap.value == '01' ? 'on' : 'off'
            sendEvent(name: "switch", unit: "", value: "$thisValue", type: null, descriptionText: 'switch attribute updated')
            runIn(2, 'refreshMeters')
            break
        case POWER_RESTORE_ID: // 0x4003
            final Map<Integer, String> options = PowerRestoreOpts.options as Map<Integer, String>
            value = hexStrToUnsignedInt(descMap.value)
            device.updateSetting('powerRestore', [value: value.toString(), type: 'enum' ])
            String valueString = ""    
            if (value == 0) {valueString = "Off"}
            if (value == 1) {valueString = "On"}
            if (value == 255) {valueString = "Last State"}
            if (debugLogging) log.debug "4003, Power Restore State is:$valueString" 
            sendEvent(name: "powerRestoreState4003", value: "$valueString", unit: null, descriptionText: "powerRestoreState4003")
            break
        case 0x4001:
			String tempvalue = descMap.value      // zigbee.swapOctets(descMap.value)
            value = Math.round(zigbee.convertHexToInt(tempvalue)) / 10
            if (debugLogging) log.debug "4001, Timed On value is: $value"
            sendEvent(name: "onTime4001", value: value, unit: null, descriptionText: "onTime4001")
            break
        case 0x4002:
			String tempvalue = descMap.value      // zigbee.swapOctets(descMap.value)
            if (tempvalue) {value = Math.round(zigbee.convertHexToInt(tempvalue)) /10}
            else {value = 0}
            if (debugLogging) log.debug "4002, Timed Off value is: $value"
            sendEvent(name: "offWait4002", value: value, unit: null, descriptionText: "offWait4002" )
            break
        default:
            log.warn "${device} zigbee received unknown ${clusterLookup(descMap.clusterInt)}: ${descMap}"
            break
    }
}

/**
 * Zigbee Groups Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseGroupsCluster(final Map descMap) {
    if (traceLogging) log.trace "parseGroupsCluster() description: $descMap"      
    switch (descMap.command as Integer) {
        case 0x00: // Add group response
            final List<String> data = descMap.data as List<String>
            final int statusCode = hexStrToUnsignedInt(data[0])
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${data[0]}"
            final int groupId = hexStrToUnsignedInt(data[2] + data[1])
            if (debugLogging) {
                log.debug "${device} zigbee response add group ${groupId}: ${statusName}"
            } else if (statusCode > 0x00) {
                log.warn "${device} zigbee response add group ${groupId} error: ${statusName}"
            }
            break
        case 0x02: // Group membership response
            final List<String> data = descMap.data as List<String>
            final int capacity = hexStrToUnsignedInt(data[0])
            final int groupCount = hexStrToUnsignedInt(data[1])
            final Set<String> groups = []
            for (int i = 0; i < groupCount; i++) {
                int pos = (i * 2) + 2
                String group = hexStrToUnsignedInt(data[pos + 1] + data[pos])
                groups.add(group)
            }
            state.groups = groups
            if (infoLogging) log.info "${device} zigbee group memberships: ${groups} (capacity available: ${capacity})"
            break
        default:
            log.warn "${device} zigbee received unknown GROUPS cluster: ${descMap}"
            break
    }
}

/**
 * ZDO (Zigbee Data Object) Clusters Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseZdoClusters(final Map descMap) {
    if (traceLogging) log.trace "parseZdoClusters() description: $descMap"   
    final Integer clusterId = descMap.clusterInt as Integer
    final String clusterName = ZdoClusterEnum[clusterId] ?: "UNKNOWN_CLUSTER (0x${descMap.clusterId})"
    final String statusHex = ((List)descMap.data)[1]
    final Integer statusCode = hexStrToUnsignedInt(statusHex)
    final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${statusHex}"
    if (statusCode > 0x00) {
        log.warn "${device} zigbee received device object ${clusterName} error: ${statusName}"
    } else if (debugLogging) {
        log.debug "${device} zigbee received device object ${clusterName} success: ${descMap.data}"
    }
}

/**
 * Calculates the power factor from the RMS voltage, RMS current and active power
 * @param rmsVoltage in V
 * @param rmsCurrent in A
 * @param activePower in W
 * @return power factor
 */
private static BigDecimal calculatePowerFactor(final BigDecimal rmsVoltage, final BigDecimal rmsCurrent, final BigDecimal activePower) {
    final BigDecimal apparentPower = rmsVoltage * rmsCurrent
    final BigDecimal powerFactor = activePower / apparentPower
    return powerFactor
}

/**
 * Checks if the specified value is at or above the minimum change from the previous value
 * @param value value to check
 * @param previousValue previous value
 * @param minimumChange minimum change
 * @return true if the value is over the minimum change, otherwise false
 * // jellyGreen changed to currentValue  and newValue
 */
private boolean isDelta(final BigDecimal currentValue, final BigDecimal newValue, final BigDecimal minimumChange) {
    boolean testResult = true
    if (currentValue > 0 && newValue != null && minimumChange > 0) {
        testResult = (currentValue - newValue).abs() >= minimumChange
    }

    if (debugLogging) {
        log.debug "isDelta(currentValue: ${currentValue}, newValue: ${newValue}, minimumChange: ${minimumChange}) = ${testResult}"
    }
    testResult = true // xxxxx added to check reporting frequency without value changes
    return testResult
}

/**
 * Lookup the cluster name from the cluster ID
 * @param cluster cluster ID
 * @return cluster name if known, otherwise "private cluster"
 */
private String clusterLookup(final Object cluster) {
    return zigbee.clusterLookup(cluster.toInteger()) ?: "private cluster 0x${intToHexStr(cluster.toInteger())}"
}

/**
 * Schedule a command timeout check
 * @param delay delay in seconds (default COMMAND_TIMEOUT)
 */
private void scheduleCommandTimeoutCheck(final int delay = COMMAND_TIMEOUT) {
    runIn(delay, 'deviceCommandTimeout')
}

/**
 * Schedule a device health check
 * @param intervalMin interval in minutes
 */
private void scheduleDeviceHealthCheck(final int intervalMin) {
    final Random rnd = new Random()
    schedule("${rnd.nextInt(59)} ${rnd.nextInt(9)}/${intervalMin} * ? * * *", 'ping')
}

/**
 * Update the specified device attribute with the specified value and log if changed
 * @param attribute name of the attribute
 * @param value value of the attribute
 * @param unit unit of the attribute
 * @param type type of the attribute
 */
private void updateAttribute(final String myattribute, final Object value, final String unit = null, final String type = null) {
    final String descriptionText = "In updateAttribute   ${myattribute} was set to ${value}${unit ?: ''}"
    if (device.currentValue(attribute) != value && (infoLogging)) {
        log.info descriptionText
    }
    sendEvent(name: myattribute, value: value, unit: unit, type: type, descriptionText: descriptionText)
    if ((myattribute == "amperage") && (value == 0)) 
        {
            sendEvent(name: "powerFactor", unit: "", value: 0.0, type: type, descriptionText: "set to zero if current is zero")
            sendEvent(name: "power", unit: "W", value: 0, type: type, descriptionText: "set to zero if current is zero")
        }
}

/**
 * Update the power factor calculation
 */
private void updatePowerFactor() {
    final BigDecimal rmsVoltage = device.currentValue('voltage') as BigDecimal
    final BigDecimal rmsCurrent = device.currentValue('amperage') as BigDecimal
    final BigDecimal activePower = device.currentValue('power') as BigDecimal
    if (rmsVoltage && rmsCurrent && activePower) {
        BigDecimal powerFactor = calculatePowerFactor(rmsVoltage, rmsCurrent, activePower)
        if (powerFactor < -1) { powerFactor = -1 } // power factor can't be less than -1
        if (powerFactor > 1) { powerFactor = 1 } // power factor can't be greater than 1
        powerFactor = powerFactor.setScale(1, RoundingMode.HALF_UP)
        sendEvent(name: "powerFactor", unit: "", value:powerFactor, type: null, descriptionText: "powerfactor attribute updated")
    }
}

private static String hexToAscii(String hexStr) {
    StringBuilder output = new StringBuilder("")
    if (hexStr.length() > 2){
        for (int i = 2; i < (hexStr.length()); i += 2) { 
        String str = hexStr.substring(i, i + 2);
        output.append((char) Integer.parseInt(str, 16));
        } 
    }
    return output.toString();
}

// innr SP242
//@Field static Map constantsMultDiv = [1536:1, 771:42, 1541:1, 1540:1, 768:0, 1539:1000, 1538:1, 1537:1]  // attribute:value - attributeInteger in Metering_Cluster & values specific to this device (read earlier)
//@Field Map readCconstantsMultDiv = [:]


// Zigbee Attribute IDs
@Field static final int AC_CURRENT_DIVISOR_ID = 0x0603  //decimal 1539  divisor is 1000 so measuring mA and divide by 1000 to present Amps
@Field static final int AC_CURRENT_MULTIPLIER_ID = 0x0602
@Field static final int AC_FREQUENCY_ID = 0x0300
@Field static final int AC_POWER_DIVISOR_ID = 0x0605
@Field static final int AC_POWER_MULTIPLIER_ID = 0x0604
@Field static final int AC_VOLTAGE_DIVISOR_ID = 0x0601
@Field static final int AC_VOLTAGE_MULTIPLIER_ID = 0x0600
@Field static final int ACTIVE_POWER_ID = 0x050B
@Field static final int ATTRIBUTE_READING_INFO_SET = 0x0000
@Field static final int FIRMWARE_VERSION_ID = 0x4000
@Field static final int PING_ATTR_ID = 0x01
@Field static final int POWER_ON_OFF_ID = 0x0000
@Field static final int POWER_RESTORE_ID = 0x4003
@Field static final int RMS_CURRENT_ID = 0x0508
@Field static final int RMS_VOLTAGE_ID = 0x0505
@Field static final int METERING_UNIT_OF_MEASURE_ID = 0x0300        // UnitofMeasure - enum8 - 0x00 to 0xFF - readable def0x00 mandatory Table 10-71 - value 00 is kWh
@Field static final int METERING_DIVISOR_ID = 0x0302                // Divisor - uint24 - 000000 to FFFFFF - readable - OPTIONAL // not available on this device
@Field static final int METERING_SUMMATION_FORMATTING_ID = 0x0303   // Summation Formating - map8 - 00 to FF - readable - mandatory

/**
Table 10-72. UnitofMeasure Attribute Enumerations
0x00 kWh (Kilowatt Hours) & kW (Kilowatts) in pure binary format
0x80 kWh (Kilowatt Hours) & kW (Kilowatts) in BCD format

10.4.2.2.4.3 Divisor Attribute
Divisor provides a value to divide the results of applying the Multiplier Attribute against a raw or uncom-
pensated sensor count of Energy, Gas, or Water being measured by the metering device. If present, this
attribute must be applied against all summation, consumption and demand values to derive the delivered
and received values expressed in the unit of measure specified.

10.4.2.2.4.4 SummationFormatting Attribute
Bits 0 to 2: Number of Digits to the right of the Decimal Point.
Bits 3 to 6: Number of Digits to the left of the Decimal Point.
Bit 7: If set, suppress leading zeros.
**/

@Field static final Map PowerRestoreOpts = [
    defaultValue: 0xFF,
    options: [ 0x00: 'Off', 0x01: 'On', 0xFF: 'Last State' ]
]

@Field static final Map HealthCheckIntervalOpts = [
    defaultValue: 10,
    options: [ 10: 'Every 10 Mins', 15: 'Every 15 Mins', 30: 'Every 30 Mins', 45: 'Every 45 Mins', 59: 'Every Hour', 00: 'Disabled' ]
]

@Field static final Map EnergyResolutionOpts = [
    defaultValue: 2,
    options: [ 0: '1kWh', 1: '0.1kWh', 2: '0.01kWh']
]

// Command timeout before setting healthState to offline
@Field static final int COMMAND_TIMEOUT = 10

// Delay in between zigbee commands
@Field static final int DELAY_MS = 300

@Field static final Map<Integer, String> ZigbeeStatusEnum = [
    0x00: 'Success',
    0x01: 'Failure',
    0x02: 'Not Authorized',
    0x80: 'Malformed Command',
    0x81: 'Unsupported COMMAND',
    0x85: 'Invalid Field',
    0x86: 'Unsupported Attribute',
    0x87: 'Invalid Value',
    0x88: 'Read Only',
    0x89: 'Insufficient Space',
    0x8A: 'Duplicate Exists',
    0x8B: 'Not Found',
    0x8C: 'Unreportable Attribute',
    0x8D: 'Invalid Data Type',
    0x8E: 'Invalid Selector',
    0x94: 'Time out',
    0x9A: 'Notification Pending',
    0xC3: 'Unsupported Cluster'
]

@Field static final Map<Integer, String> ZdoClusterEnum = [
    0x0013: 'Device announce',
    0x8004: 'Simple Descriptor Response',
    0x8005: 'Active Endpoints Response',
    0x801D: 'Extended Simple Descriptor Response',
    0x801E: 'Extended Active Endpoint Response',
    0x8021: 'Bind Response',
    0x8022: 'Unbind Response',
    0x8023: 'Bind Register Response',
]

@Field static final Map<Integer, String> ZigbeeGeneralCommandEnum = [
    0x00: 'Read Attributes',
    0x01: 'Read Attributes Response',
    0x02: 'Write Attributes',
    0x03: 'Write Attributes Undivided',
    0x04: 'Write Attributes Response',
    0x05: 'Write Attributes No Response',
    0x06: 'Configure Reporting',
    0x07: 'Configure Reporting Response',
    0x08: 'Read Reporting Configuration',
    0x09: 'Read Reporting Configuration Response',
    0x0A: 'Report Attributes',
    0x0B: 'Default Response',
    0x0C: 'Discover Attributes',
    0x0D: 'Discover Attributes Response',
    0x0E: 'Read Attributes Structured',
    0x0F: 'Write Attributes Structured',
    0x10: 'Write Attributes Structured Response',
    0x11: 'Discover Commands Received',
    0x12: 'Discover Commands Received Response',
    0x13: 'Discover Commands Generated',
    0x14: 'Discover Commands Generated Response',
    0x15: 'Discover Attributes Extended',
    0x16: 'Discover Attributes Extended Response'
]    

/**
state.clear()
settings.clear()
state.remove("version")
settings.remove("logDebug")

def removeAllSettings() {
    log.debug "before: " + settings
    // Copy keys set first to avoid any chance of concurrent modification
    def keys = new HashSet(settings.keySet())
    keys.each{ key -> device.removeSetting(key) }
    log.debug " after: " + settings
}
**/
