/**
 *  MIT License
 *  Copyright 2023 Jonathan Bradshaw (jb@nrgup.net)
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the 'Software'), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 *    This software was created by Jonathan Bradshaw for a smart plug / outlet by 
 *    manufacturer: 'Third Reality, Inc' (model: '3RSP02028BZ'), but it has been edited and
 *    amended by jellygreen, on the same copyright basis, to enable it to be
 *    used on HUBITAT hubs with an innr SP 242 smart plug /outlet with power monitoring.  
 *    Frequency measurements do not appear to have been implemented on this device
 *    and so that has been disabled.  For the moment - healthchecking, and Firmware updating
 *    have also been disabled for now - as has time limited debug logging
 */

import groovy.transform.Field
import hubitat.zigbee.zcl.DataType
import java.math.RoundingMode

metadata {
    definition(name: 'Innr SP 242 Power Meter Plug v1.1.5', namespace: 'Innr', author: 'Jonathan Bradshaw - edited by jellygreen', singleThreaded: true) {
        
        capability 'Actuator'
        capability 'Configuration'
        capability 'CurrentMeter'
        capability 'EnergyMeter'
        capability "Initialize"
        capability 'Outlet'
        capability 'PowerMeter'
        capability 'Refresh'
        capability 'Sensor'
        capability 'Switch'
        capability 'VoltageMeasurement'
        capability 'HealthCheck'

        command 'toggle'
        command 'installed'
        command 'onePressSetup', [[name:"Preferences first then One Press Setup, wait for 10 seconds then reload the page", description: "Press, wait for 10 seconds then reload the page" ] ] //
        
        // command 'updateFirmware'
        attribute 'healthStatus', 'enum', [ 'unknown', 'offline', 'online' ]
        
        attribute 'powerFactor', 'number'         // calculated, not read

        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0008,1000,0702,0B04,E001", outClusters:"000A,0019", model:"SP 242", manufacturer:"innr"
    }

/**
name - Uniquely identifies this setting
type - The data type of the setting which may be one of bool, date, decimal, email, enum, number, password, time, text.
title - The text to be shown in the driver UI
description - The long text description of the setting
required - [true/false] - Specifies whether or not this setting requires a value
defaultValue - The default value of the setting if none is specified
options - Only available when the type is enum. Allows you to specify the values that appear in the dropdown.
multiple - Only available when the type is enum. Specifies that multiple values can be selected from the dropdown.
range - Only available when the type is number or decimal. A string in the format low..high that specifies the range of valid numeric values.
**/
    
    
    preferences {
        input name: 'powerRestore', type: 'enum', title: '<b>Power Restore Mode</b>', options: PowerRestoreOpts.options, defaultValue: PowerRestoreOpts.defaultValue, description:'<i>Changes what happens when power is restored to outlet.</i>'

        input name: 'HealthCheckInterval', type: 'enum', title: '<b>HealthCheck Interval</b> ping using energy refresh', options: HealthCheckIntervalOpts.options, defaultValue: HealthCheckIntervalOpts.defaultValue, description:\
            '<i>Changes how often the hub pings outlet to check health.</i>'

        input name: 'disableOnOff', type: 'bool', title: '<b>Disable Power Commands</b>', defaultValue: false, description: '<i>Disables the driver power commands to stop accidental changes.</i>'

        input name: 'powerDelta', type: 'number', title: '<b>Power Minimum Change</b>', defaultValue: 10, description:'<i>The minimum power change Watts that device will report, range is 1 to 1000, default ais 10 (10W).</i>', range:'1..1000'

        input name: 'energyDelta', type: 'number', title: '<b>Energy Minimum Change</b>', defaultValue: 10, description:'<i>The minimum energy change that will be recorded in 1/100ths of 1kWh, range is 10 to 100, default is 10 (0.1kWh).</i>', range: '1..100'

        input name: 'amperageDelta', type: 'number', title: '<b>Amperage Minimum Change - mA</b>', defaultValue: 100, description: '<i>The minimum amperage change (in milliAmps, mA) that will be recorded, range is 5 to 1000, default is 100 (100mA, 0.1A).</i>', range: '5..1000'

        input name: 'voltageDelta', type: 'number', title: '<b>Voltage Minimum Change</b>', defaultValue: 5, description:'<i>The minimum voltage change V that will be recorded, range is 1 to 100, default is 5 (5V), .</i>', range: '1..100'

        input name: 'infoLogging', type: 'bool', title: '<b>Enable descriptionText logging</b>', defaultValue: true, description: '<i>Enables command logging.</i>'

        input name: 'debugLogging', type: 'bool', title: '<b>Enable debug logging</b>', defaultValue: false, description:'<i>Turns on debug logging for 30 minutes.</i>'
        
        input name: 'periodicReportingOnOff', type: 'bool', title:'<b>Enable Periodic Reporting</b>', defaultValue: true, description:'on, adds periodic reporting to change based reporting from the device'
        
        input name:'periodicReportingPeriod', type: 'number', title: '<b>Periodic Reporting Period in Seconds</b>', defaultValue: 3600, description:'periodic reporting period in seconds, default and minimum is one hour, 3600s', range:'360..43200'
    }
}

@Field static final String VERSION = '1.1.5 (2024-01-29)'

def onePressSetup(){
    initialize()
    runIn(1, 'configure')
    runIn(5, 'refresh') 
    if (infoLogging) log.info "${device.displayName} onePressSetup - done"
}

def initialize(){         
    // state.constantsMultDiv = [1536:1, 771:42, 1541:1, 1540:1, 768:0, 1539:1000, 1538:1, 1537:1]  // attribute:value - attributeInteger in Metering_Cluster & values specific to this device (read earlier)
    //state.remove('isDigital')
    //state.remove('checkPhase')
    // state.values = [0:0, 1288:0, 1285:0, 1291:0]                                                 // attribute:value - attributeInteger in Electrical_Measurement_Cluster & zero values
    // if (state.constantsMultDiv == null) { state.constantsMultDiv = [:] }                      // only needed if being obtained through readAttributes
    // if (state.values == null) { state.values = [:] }                                          // only needed if being obtained through readAttributes
    
    def initializeCommands = []
    initializeCommands += zigbee.readAttribute(zigbee.ON_OFF_CLUSTER, POWER_RESTORE_ID, [:], DELAY_MS) // Get Power Restore state

/**                                                                                              // only needed if being obtained through readAttributes
    initializeCommands += zigbee.readAttribute(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, [          // Get Power Measurement Formatting
        AC_CURRENT_MULTIPLIER_ID,
        AC_CURRENT_DIVISOR_ID,
        AC_VOLTAGE_MULTIPLIER_ID,
        AC_VOLTAGE_DIVISOR_ID,
        AC_POWER_MULTIPLIER_ID,
        AC_POWER_DIVISOR_ID
    ], [:], DELAY_MS)

    initializeCommands += zigbee.readAttribute(zigbee.METERING_CLUSTER, [                        // Get Measurement Formatting
        //METERING_DIVISOR_ID,               // 0x0302 is an invalid attribute for cluster 0x0702 on this device
        METERING_UNIT_OF_MEASURE_ID,         // 0x0300 is valid - returns value 00 which is kWh
        METERING_SUMMATION_FORMATTING_ID     // 0x0303 is valid - returns value 2A
        
    ], [:], DELAY_MS)
**/       
    if (debugLogging) log.debug "initializeCommands(): $initializeCommands"
    state.driverInitializedDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
    if (infoLogging) log.info "JellyGreen's driver for ${device.displayName} initialized"
	return initializeCommands   // delayBetween(initializeCommands,500)                          // only needed if being obtained through readAttributes
}

def configure() {        
// populate some default values for attributes - // no point refresh will do this
/**    sendEvent(name: "amperage", value: 0, unit: "A")
    sendEvent(name: 'energy', value: 0, unit: 'kWh')
    sendEvent(name: "power", value: 0, unit: "W")
    sendEvent(name: "switch", value: "off")
    sendEvent(name: "voltage", value: 0, unit: "V")
    sendEvent(name: 'powerFactor', value: 0)
    // sendEvent(name: 'frequency', value: 0, unit: 'Hz')
    // sendEvent(name: 'healthStatus', value: 'unknown')
**/    
                                // Configure reporting - Invoked when device is first installed and when the user commands
                                // Out of the box reporting is only ON_OFF_CLUSTER - uncertain - minReportingInterval: 0, maxReportingInterval: 240 
                                // 0 to 43200 in seconds (12 hours) // 360 is 6 minutes
    
    def int reportingPeriod = settings.periodicReportingPeriod
    if (settings.periodicReportingOnOff == false) reportingPeriod = 0
    
    def int powerDelta = settings.powerDelta  // try 1 which should give a min delta of 1W
    def int voltageDelta = settings.voltageDelta * 10 // try no factor which should give delta of 1V    
    def int amperageDelta = settings.amperageDelta   // no multiplier needed, as value is milliamps, mA
    def int energyDelta = settings.energyDelta // try 100 which should give delta of 0.1kWH
    
    // log.info "energyDelta is $energyDelta"
    
    List<String> cmds = []
    if (settings.powerRestore != null) { cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, POWER_RESTORE_ID, DataType.ENUM8, settings.powerRestore as Integer, [:], DELAY_MS) }
    cmds += zigbee.configureReporting(zigbee.ON_OFF_CLUSTER, POWER_ON_OFF_ID, DataType.BOOLEAN, 0, reportingPeriod, null, [:], DELAY_MS)    // switch state
    cmds += zigbee.configureReporting(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, ACTIVE_POWER_ID, DataType.INT16, 0, reportingPeriod, powerDelta, [:], DELAY_MS)    //power reporting - min change in W was 10
    cmds += zigbee.configureReporting(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, RMS_VOLTAGE_ID, DataType.UINT16, 0, reportingPeriod, voltageDelta, [:], DELAY_MS)    //voltage reporting - min change in volts was 10
    cmds += zigbee.configureReporting(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, RMS_CURRENT_ID, DataType.UINT16, 0, reportingPeriod, amperageDelta, [:], DELAY_MS)    //current reporting  - min change in mA was 100
    cmds += zigbee.configureReporting(zigbee.METERING_CLUSTER, ATTRIBUTE_READING_INFO_SET, 0x25, 360, reportingPeriod, energyDelta)  //, [:], DELAY_MS)      // energy reporting - min change in Wh was 10 // DataType.UINT48 is 0x25
    // cmds += zigbee.configureReporting(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, AC_FREQUENCY_ID, DataType.UINT16, 0, 240, 10, [:], DELAY_MS)
    if (debugLogging) log.debug "configureCommands(): $Cmds"
    state.driverConfiguredDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
    if (infoLogging) log.info "JellyGreen's driver for ${device.displayName} configured with periodicReporting as ${settings.periodicReportingOnOff} and a periodicReportingPeriod of $reportingPeriod seconds"    
    return cmds
}



void installed() {    //Invoked by Hubitat when driver is installed
    onePressSetup()
    state.driverInstalledDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
    if (infoLogging) log.info "${device.displayName} installed by JellyGreen's driver" 
}


void logsOff() {    //  Disable logging (for debugging)
    log.warn "${device.displayName} debug logging disabled..."
    device.updateSetting('debugLogging', [value: 'false', type: 'bool'])
}


def deviceCommandTimeout() {    //Send health status event upon a timeout
    log.warn "${device.displayName} no response received (device offline?)"
    sendEvent(name: "healthStatus",  unit: null, value: "offline", type: null, descriptionText: "healthStatus attribute gone offline")
}


def ping() {    // Ping Command
    if (debugLogging) log.debug "${device.displayName} ping..."       // Using energy read METERING_CLUSTER attribute 0x00 as a simple ping/pong mechanism
    scheduleCommandTimeoutCheck()
    return  zigbee.readAttribute(zigbee.METERING_CLUSTER, ATTRIBUTE_READING_INFO_SET, [:], 0)    // was using info cluster for ping -  zigbee.readAttribute(zigbee.BASIC_CLUSTER, PING_ATTR_ID, [:], 0)
}

def refresh() {    //  Refresh Command
    log.info "${device.displayName} refresh command"
    // state.values = [:]
    def refreshCommands = []
    // refreshCommands += zigbee.readAttribute(zigbee.BASIC_CLUSTER, FIRMWARE_VERSION_ID, [:], DELAY_MS)           // Get Firmware Version
    refreshCommands += zigbee.readAttribute(zigbee.ON_OFF_CLUSTER, POWER_ON_OFF_ID, [:], DELAY_MS)              // Get Power On/Off state
    refreshCommands += zigbee.readAttribute(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, [                            // Get Voltage, ampage and power measurements
        // AC_FREQUENCY_ID,
        RMS_CURRENT_ID,
        RMS_VOLTAGE_ID,
        ACTIVE_POWER_ID
    ], [:], DELAY_MS)
    refreshCommands += zigbee.readAttribute(zigbee.METERING_CLUSTER, ATTRIBUTE_READING_INFO_SET, [:], DELAY_MS) // Get energy measurement

    // Get Reporting Configuration (for debug - uncomment what is needed)
    if (settings.debugLogging) {
        //refreshCommands += zigbee.reportingConfiguration(zigbee.ON_OFF_CLUSTER, POWER_ON_OFF_ID, [:], DELAY_MS)
        //refreshCommands += zigbee.reportingConfiguration(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, ACTIVE_POWER_ID, [:], DELAY_MS)
        //refreshCommands += zigbee.reportingConfiguration(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, RMS_CURRENT_ID, [:], DELAY_MS)
        //refreshCommands += zigbee.reportingConfiguration(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, RMS_VOLTAGE_ID, [:], DELAY_MS)
        // refreshCommands += zigbee.reportingConfiguration(zigbee.ELECTRICAL_MEASUREMENT_CLUSTER, AC_FREQUENCY_ID, [:], DELAY_MS)  // CLUSTER 0B04 FREQUENCY ATTRIBUTE 0X0300
        //refreshCommands += zigbee.reportingConfiguration(zigbee.METERING_CLUSTER, ATTRIBUTE_READING_INFO_SET, [:], DELAY_MS)
        // Management LQI (Neighbor Table) Request (response is 0x8031)
        //refreshCommands += "he raw ${device.deviceNetworkId} 0x01 0x00 0x0031 { 01 00 } { 0000 }"
        // Management Rtg (Routing Table) Request (response is 0x8032)
        //refreshCommands += "he raw ${device.deviceNetworkId} 0x01 0x00 0x0032 { 01 00 } { 0000 }"
    }

    scheduleCommandTimeoutCheck()
    if (debugLogging) log.debug "refresh() commands: $refreshCommands"
    state.driverRefreshedDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
	return refreshCommands // delayBetween(refreshCommands,20)
}

def updated() {         // Invoked by Hubitat when the driver configuration is updated
     unschedule()
     //state.remove('.... ') // legacy
    if (settings.debugLogging) {
        log.debug settings
        runIn(1800, logsOff)
    }
    final int interval = (settings.HealthCheckInterval as Integer) ?: 0
    if (interval > 0) {
        log.info "${device} scheduling health check every ${interval} minutes"
        scheduleDeviceHealthCheck(interval)
    }
    runIn(1, 'configure')
    state.driverUpdatedDateTime = new Date().format("dd/MMM/yyyy HH:mm:ss")
    if (infoLogging) log.info "${device.displayName} Updated by JellyGreen's driver version ${VERSION}"            
}

/**
 * Update Firmware Command
 * @return List of zigbee commands
List<String> updateFirmware() {
    log.info 'checking for firmware updates'
    return zigbee.updateFirmware()
}
**/ 

def on() {    // On Command
    if (settings.disableOnOff) { return [] }
    if (infoLogging) log.info "${device.displayName} turn on command"
    scheduleCommandTimeoutCheck()
    runIn(2, 'refresh')
    return zigbee.on()
}
def off() {    //    Off Command
    if (settings.disableOnOff) { return [] }
    if (infoLogging) log.info  "${device.displayName} turn off command" 
    scheduleCommandTimeoutCheck()
    runIn(2, 'refresh')
    return zigbee.off()
}

def toggle() {                             // Toggle Command (On/Off)
    if (settings.disableOnOff) { return [] }
    if (infoLogging) log.info "${device.displayName} toggle command"
    scheduleCommandTimeoutCheck()
    runIn(2, 'refresh')
    return zigbee.command(zigbee.ON_OFF_CLUSTER, 0x02, [:], 0)
}



def parse(description) {                                            // Parse Zigbee message
    // if (debugLogging) log.trace "parse() description: $description"
    def Map descMap = zigbee.parseDescriptionAsMap(description)
    
    if (device.currentValue('healthStatus') != 'online') {sendEvent(name: "healthStatus",  unit: null, value: "online", type: null, descriptionText: "healthStatus attribute gone online")}
    unschedule('deviceCommandTimeout')

    if (descMap.profileId == '0000') {
        // parseZdoClusters(descMap)
        if (debugLogging) log.debug "Zdo Cluster information received and ignored"
        return
    }

    if (descMap.isClusterSpecific == false) {
        parseGeneralCommandResponse(descMap)
        return
    }

    if (settings.debugLogging) {
        final String clusterName = clusterLookup(descMap.clusterInt)
        final String attribute = descMap.attrId ? " attribute 0x${descMap.attrId} (value ${descMap.value})" : ''
        if (settings.debugLogging) { log.debug "${device} zigbee received ${clusterName} message" + attribute }
    }

    switch (descMap.clusterInt as Integer) {
        case zigbee.BASIC_CLUSTER:
            parseBasicCluster(descMap)
            descMap.remove('additionalAttrs')?.each { final Map map -> parseBasicCluster(descMap + map) }
            break
        case zigbee.ELECTRICAL_MEASUREMENT_CLUSTER:
            //if (state.constantsMultDiv == null) { state.constantsMultDiv = [:] }
            //if (state.values == null) { state.values = [:] }
            parseElectricalMeasureCluster(descMap)
            descMap.remove('additionalAttrs')?.each { final Map map -> parseElectricalMeasureCluster(descMap + map) }
            break
        case zigbee.METERING_CLUSTER:
            //if (state.values == null) { state.values = [:] }
            parseMeteringCluster(descMap)
            descMap.remove('additionalAttrs')?.each { final Map map -> parseMeteringCluster(descMap + map) }
            break
        case zigbee.ON_OFF_CLUSTER:
            parseOnOffCluster(descMap)
            descMap.remove('additionalAttrs')?.each { final Map map -> parseOnOffCluster(descMap + map) }
            break
        default:
            if (settings.debugLogging) {
                log.debug "zigbee received unknown message cluster: ${descMap}"
            }
            break
    }
}

/**
 * Zigbee Basic Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseBasicCluster(final Map descMap) {
        if (debugLogging) log.trace "parseBasicCluster() description: $descMap"
    switch (descMap.attrInt as Integer) {
        case 0x0000:  // PING_ATTR_ID: // Using 0x01 read as a simple ping/pong mechanism
            if (debugLogging) { log.debug 'pong..' }
            break
        case FIRMWARE_VERSION_ID:
            final String version = descMap.value ?: 'unknown'
            log.info "${device} device firmware version is ${version}"
            updateDataValue('softwareBuild', version)
            break
        default:
            log.warn "${device} zigbee received unknown Basic cluster attribute 0x${descMap.attrId} (value ${descMap.value})"
            break
    }
}

/**
 * Zigbee Electrical Measurement Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseElectricalMeasureCluster(final Map descMap) {
    if (debugLogging) log.trace "parseElectricalMeasureCluster() description: $descMap"
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value
    final long value = hexStrToUnsignedInt(descMap.value)
    switch (descMap.attrInt as Integer) {
        case AC_CURRENT_DIVISOR_ID:
        case AC_CURRENT_MULTIPLIER_ID:
        case AC_POWER_DIVISOR_ID:
        case AC_POWER_MULTIPLIER_ID:
        case AC_VOLTAGE_DIVISOR_ID:
        case AC_VOLTAGE_MULTIPLIER_ID:
            readConstantsMultDiv[descMap.attrInt as String] = value
            break
        case AC_FREQUENCY_ID:
            // updateAttribute('frequency', value, 'Hz', 'physical')
            break
        case RMS_CURRENT_ID:
            handleRmsCurrentValue(value)
            break
        case ACTIVE_POWER_ID:
            handleActivePowerValue(value)
            break
        case RMS_VOLTAGE_ID:
            handleRmsVoltageValue(value)
            break
        default:
            log.warn "${device} zigbee received unknown Electrical Measurement cluster attribute 0x${descMap.attrId} (value ${descMap.value})"
            break
    }
}

/**
 * Handle RMS Current Value updates
 * @param value The new RMS Current Value
 */
void handleRmsCurrentValue(final long value) {  //Amperage value stored on the device is in mA - multiplier is 1 and divisor is 1000
    final Integer multiplier = 1 //  constantsMultDiv[AC_CURRENT_MULTIPLIER_ID as String] as Integer
    final Integer divisor = 1000 // constantsMultDiv[AC_CURRENT_DIVISOR_ID as String] as Integer
    if (multiplier > 0 && divisor > 0) {
        final BigDecimal lastValue = 0 // state.values[RMS_CURRENT_ID as String] as BigDecimal
        BigDecimal result = value * multiplier / divisor
        result = result.setScale(3, RoundingMode.HALF_UP)
        sendEvent(name: "amperage",  unit: "A", value: result, type: null, descriptionText: "amperage attribute updated")
        if ((result == 0)) 
            {
            sendEvent(name: "powerFactor", unit: "", value: 0.0, type: type, descriptionText: "set to zero if current is zero")
            sendEvent(name: "power", unit: "W", value: 0, type: type, descriptionText: "set to zero if current is zero")
            }       
        else
            {
            updatePowerFactor()
            }
    }
}

/**
 * Handle Active Power Value updates
 * @param value The new Power Value
 */
void handleActivePowerValue(final long value) {  //Power value stored on the device is in Watts - multiplier is 1 and divisor is 1
    final Integer multiplier = 1 // constantsMultDiv[AC_POWER_MULTIPLIER_ID as String] as Integer
    final Integer divisor = 1  // constantsMultDiv[AC_POWER_DIVISOR_ID as String] as Integer
    if (multiplier > 0 && divisor > 0) {
        final BigDecimal lastValue = 0 //state.values[ACTIVE_POWER_ID as String] as BigDecimal
        BigDecimal result = (int)value * multiplier / divisor
        result = result.setScale(0, RoundingMode.HALF_UP)  // was 1
        sendEvent(name: "power",  unit: "W", value: result, type: null, descriptionText: "power attribute updated")
        updatePowerFactor()
        }
        //}
}

/**
 * Handle RMS Voltage Value updates
 * @param value The new Voltage Value
 */
void handleRmsVoltageValue(final long value) {    //Voltage value stored on the device is in volts - multiplier is 1 and divisor is 1
    final Integer multiplier = 1 //constantsMultDiv[AC_VOLTAGE_MULTIPLIER_ID as String] as Integer
    final Integer divisor = 1 // constantsMultDiv[AC_VOLTAGE_DIVISOR_ID as String] as Integer
    if (multiplier > 0 && divisor > 0) {
        final BigDecimal lastValue = 0 // state.values[RMS_VOLTAGE_ID as String] as BigDecimal
        BigDecimal result = value * multiplier / divisor
        result = result.setScale(0, RoundingMode.HALF_UP)
        sendEvent(name: "voltage",  unit: "V", value: result, type: null, descriptionText: "voltage attribute updated")
        updatePowerFactor()
    }
}

/**
 * Zigbee General Command Parsing
 * @param descMap Zigbee message in parsed map format
 */
def parseGeneralCommandResponse(descMap) {
    if (debugLogging) log.trace "parseGeneralCommandResponse() description: $descMap"    
    def int commandId = hexStrToUnsignedInt(descMap.command)
    switch (commandId) {
        case 0x01: // read attribute response
            parseReadAttributeResponse(descMap)
            break
        case 0x04: // write attribute response
            parseWriteAttributeResponse(descMap)
            break
        case 0x07: // configure reporting response
            final String status = ((List)descMap.data).first()
            final int statusCode = hexStrToUnsignedInt(status)
            if (statusCode == 0x00 && settings.enableReporting != false) {
                if (debugLogging) log.debug "reportingEnabled = true"  // reportingEnabled - does not seem to be used anywhere except here - so just log it
            }
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${status}"
            if (statusCode > 0x00) {
                log.warn "${device} zigbee configure reporting error: ${statusName} ${descMap}"
            } else if (settings.debugLogging) {
                log.debug "${device} zigbee configure reporting response: ${statusName} ${descMap.data}"
            }
            break
        case 0x09: // read reporting configuration response
            parseReadReportingConfigResponse(descMap)
            break
        case 0x0B: // default command response
            parseDefaultCommandResponse(descMap)
            break
        default:
            final String commandName = ZigbeeGeneralCommandEnum[commandId] ?: "UNKNOWN_COMMAND (0x${descMap.command})"
            final String clusterName = clusterLookup(descMap.clusterInt)
            final String status = descMap.data in List ? ((List)descMap.data).last() : descMap.data
            final int statusCode = hexStrToUnsignedInt(status)
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${status}"
            if (statusCode > 0x00) {
                log.warn "${device} zigbee ${commandName} ${clusterName} error: ${statusName}"
            } else if (settings.debugLogging) {
                log.debug "${device} zigbee ${commandName} ${clusterName}: ${descMap.data}"
            }
            break
    }
}

/**
 * Zigbee Default Command Response Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseDefaultCommandResponse(final Map descMap) {
    if (debugLogging) log.trace "parseDefaultCommandResponse() description: $descMap"  
    final List<String> data = descMap.data as List<String>
    final String commandId = data[0]
    final int statusCode = hexStrToUnsignedInt(data[1])
    final String status = ZigbeeStatusEnum[statusCode] ?: "0x${data[1]}"
    if (statusCode > 0x00) {
        log.warn "${device} zigbee ${clusterLookup(descMap.clusterInt)} command 0x${commandId} error: ${status}"
    } else if (settings.debugLogging) {
        log.debug "${device} zigbee ${clusterLookup(descMap.clusterInt)} command 0x${commandId} response: ${status}"
    }
}

/**
 * Zigbee Metering Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseMeteringCluster(final Map descMap) {        // ClusterId 0x0702
    if (debugLogging) log.debug "parseMeteringCluster() description: $descMap"      
    if (descMap.value == null || descMap.value == 'FFFF') 
    {       // invalid or unknown value
            if (debugLogging) log.debug "descMap. value is null or value is FFFF"
            return
    } 
    final long value = hexStrToUnsignedInt(descMap.value)
    //if (debugLogging) log.debug "value is $value"
    switch (descMap.attrInt as Integer) {
        case ATTRIBUTE_READING_INFO_SET:        // used this read as a simple ping/pong mechanism
            if (debugLogging) { log.debug 'pong..kWh' }
            final Long divisor = 100 // put 100 in here to see as METERING_DIVISOR_ID fails as no attribute used to say ... //  constantsMultDiv[METERING_DIVISOR_ID as String] as Long
            final BigDecimal currentValue = 0 // state.values[ATTRIBUTE_READING_INFO_SET as String] as BigDecimal  // put 0 in here to see // 
            if (divisor > 0) {
                BigDecimal result = value / divisor
                result = result.setScale(2, RoundingMode.HALF_UP)
                final String unit = "kWh" // constantsMultDiv[METERING_UNIT_OF_MEASURE_ID as String] == 0 ? 'kWh' : '' // "kWh" // put kWh to see // 
                sendEvent(name: "energy",  unit: "kWh", value: result, type: null, descriptionText: "energy attribute updated")
             }
            break
        case METERING_DIVISOR_ID:
        case METERING_UNIT_OF_MEASURE_ID:
        case METERING_SUMMATION_FORMATTING_ID:
            //readConstantsMultDiv[descMap.attrInt as String] = value
            break
        default:
            log.warn "${device} zigbee received unknown Metering cluster attribute 0x${descMap.attrId} (value ${descMap.value})"
            break
    }
}

/**
 * Zigbee Read Attribute Response Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseReadAttributeResponse(final Map descMap) {
    if (debugLogging) log.trace "parseReadAttributeResponse() description: $descMap"  
    final List<String> data = descMap.data as List<String>
    final String attribute = data[1] + data[0]
    final int statusCode = hexStrToUnsignedInt(data[2])
    final String status = ZigbeeStatusEnum[statusCode] ?: "0x${data}"
    if (settings.logEnadebugLoggingble) {
        log.debug "${device} zigbee read ${clusterLookup(descMap.clusterInt)} attribute 0x${attribute} response: ${status} ${data}"
    } else if (statusCode > 0x00) {
        log.warn "${device} zigbee read ${clusterLookup(descMap.clusterInt)} attribute 0x${attribute} error: ${status}"
    }
}

/**
 * Zigbee Read Reporting Configuration Response Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseReadReportingConfigResponse(final Map descMap) {
    if (debugLogging) log.trace "parseReadReportingConfigResponse() description: $descMap"      
    final List<String> data = descMap.data as List<String>
    final String status = data.first()
    final int statusCode = hexStrToUnsignedInt(status)
    final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${status}"
    if (statusCode > 0x00) {
        log.warn "${device} zigbee read reporting config error: ${statusName} ${descMap.data}"
        return
    } else if (settings.debugLogging) {
        log.debug "${device} zigbee read reporting config: ${statusName} ${descMap.data}"
    }
    if (data[1] != '00') {
        return
    }
    final String attribute = '0x' + data[3] + data[2]
    final int dataType = hexStrToUnsignedInt(data[4])
    final int minReportingInterval = hexStrToUnsignedInt(data[6] + data[5])
    final int maxReportingInterval = hexStrToUnsignedInt(data[8] + data[7])
    Integer reportableChange = null
    if (!DataType.isDiscrete(dataType)) {
        final int start = DataType.getLength(dataType) + 8
        reportableChange = hexStrToUnsignedInt(data[start..9].join())
    }
    log.info "${device} zigbee reporting configuration [attribute: ${attribute}, dataType: ${dataType}, minReportingInterval: ${minReportingInterval}, maxReportingInterval: ${maxReportingInterval}, reportableChange: ${reportableChange}]"
}

/**
 * Zigbee Write Attribute Response Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseWriteAttributeResponse(final Map descMap) {
    if (debugLogging) log.trace "parseWriteAttributeResponse() description: $descMap"       
    final String data = descMap.data in List ? ((List)descMap.data).first() : descMap.data
    final int statusCode = hexStrToUnsignedInt(data)
    final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${data}"
    if (settings.debugLogging) {
        log.debug "${device} zigbee response write ${clusterLookup(descMap.clusterInt)} attribute response: ${statusName}"
    } else if (statusCode > 0x00) {
        log.warn "${device} zigbee response write ${clusterLookup(descMap.clusterInt)} attribute error: ${statusName}"
    }
}

/**
 * Zigbee Groups Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseGroupsCluster(final Map descMap) {
    if (debugLogging) log.trace "parseGroupsCluster() description: $descMap"      
    switch (descMap.command as Integer) {
        case 0x00: // Add group response
            final List<String> data = descMap.data as List<String>
            final int statusCode = hexStrToUnsignedInt(data[0])
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${data[0]}"
            final int groupId = hexStrToUnsignedInt(data[2] + data[1])
            if (settings.debugLogging) {
                log.debug "${device} zigbee response add group ${groupId}: ${statusName}"
            } else if (statusCode > 0x00) {
                log.warn "${device} zigbee response add group ${groupId} error: ${statusName}"
            }
            break
        case 0x02: // Group membership response
            final List<String> data = descMap.data as List<String>
            final int capacity = hexStrToUnsignedInt(data[0])
            final int groupCount = hexStrToUnsignedInt(data[1])
            final Set<String> groups = []
            for (int i = 0; i < groupCount; i++) {
                int pos = (i * 2) + 2
                String group = hexStrToUnsignedInt(data[pos + 1] + data[pos])
                groups.add(group)
            }
            state.groups = groups
            log.info "${device} zigbee group memberships: ${groups} (capacity available: ${capacity})"
            break
        default:
            log.warn "${device} zigbee received unknown GROUPS cluster: ${descMap}"
            break
    }
}

/**
 * Zigbee On Off Cluster Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseOnOffCluster(final Map descMap) {
    if (debugLogging) log.trace "parseOnOffCluster() description: $descMap"      
    switch (descMap.attrInt as Integer) {
        case POWER_ON_OFF_ID:
            def thisValue = descMap.value == '01' ? 'on' : 'off'
            sendEvent(name: "switch", unit: "", value: "$thisValue", type: null, descriptionText: 'switch attribute updated')
            break
        case POWER_RESTORE_ID:
            final Map<Integer, String> options = PowerRestoreOpts.options as Map<Integer, String>
            final Integer value = hexStrToUnsignedInt(descMap.value)
            log.info "${device} power restore mode is '${options[value]}' (0x${descMap.value})"
            device.updateSetting('powerRestore', [value: value.toString(), type: 'enum' ])
            break
        default:
            log.warn "${device} zigbee received unknown ${clusterLookup(descMap.clusterInt)}: ${descMap}"
            break
    }
}

/**
 * ZDO (Zigbee Data Object) Clusters Parsing
 * @param descMap Zigbee message in parsed map format
 */
void parseZdoClusters(final Map descMap) {
    if (debugLogging) log.trace "parseZdoClusters() description: $descMap"   
    final Integer clusterId = descMap.clusterInt as Integer
    final String clusterName = ZdoClusterEnum[clusterId] ?: "UNKNOWN_CLUSTER (0x${descMap.clusterId})"
    final String statusHex = ((List)descMap.data)[1]
    final Integer statusCode = hexStrToUnsignedInt(statusHex)
    final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${statusHex}"
    if (statusCode > 0x00) {
        log.warn "${device} zigbee received device object ${clusterName} error: ${statusName}"
    } else if (settings.debugLogging) {
        log.debug "${device} zigbee received device object ${clusterName} success: ${descMap.data}"
    }
}

/**
 * Calculates the power factor from the RMS voltage, RMS current and active power
 * @param rmsVoltage in V
 * @param rmsCurrent in A
 * @param activePower in W
 * @return power factor
 */
private static BigDecimal calculatePowerFactor(final BigDecimal rmsVoltage, final BigDecimal rmsCurrent, final BigDecimal activePower) {
    final BigDecimal apparentPower = rmsVoltage * rmsCurrent
    final BigDecimal powerFactor = activePower / apparentPower
    return powerFactor
}

/**
 * Checks if the specified value is at or above the minimum change from the previous value
 * @param value value to check
 * @param previousValue previous value
 * @param minimumChange minimum change
 * @return true if the value is over the minimum change, otherwise false
 * // jellyGreen changed to currentValue  and newValue
 */
private boolean isDelta(final BigDecimal currentValue, final BigDecimal newValue, final BigDecimal minimumChange) {
    boolean testResult = true
    if (currentValue > 0 && newValue != null && minimumChange > 0) {
        testResult = (currentValue - newValue).abs() >= minimumChange
    }

    if (settings.debugLogging) {
        log.debug "isDelta(currentValue: ${currentValue}, newValue: ${newValue}, minimumChange: ${minimumChange}) = ${testResult}"
    }
    testResult = true // xxxxx added to check reporting frequency without value changes
    return testResult
}

/**
 * Lookup the cluster name from the cluster ID
 * @param cluster cluster ID
 * @return cluster name if known, otherwise "private cluster"
 */
private String clusterLookup(final Object cluster) {
    return zigbee.clusterLookup(cluster.toInteger()) ?: "private cluster 0x${intToHexStr(cluster.toInteger())}"
}

/**
 * Schedule a command timeout check
 * @param delay delay in seconds (default COMMAND_TIMEOUT)
 */
private void scheduleCommandTimeoutCheck(final int delay = COMMAND_TIMEOUT) {
    runIn(delay, 'deviceCommandTimeout')
}

/**
 * Schedule a device health check
 * @param intervalMin interval in minutes
 */
private void scheduleDeviceHealthCheck(final int intervalMin) {
    final Random rnd = new Random()
    schedule("${rnd.nextInt(59)} ${rnd.nextInt(9)}/${intervalMin} * ? * * *", 'ping')
}

/**
 * Update the specified device attribute with the specified value and log if changed
 * @param attribute name of the attribute
 * @param value value of the attribute
 * @param unit unit of the attribute
 * @param type type of the attribute
 */
private void updateAttribute(final String myattribute, final Object value, final String unit = null, final String type = null) {
    final String descriptionText = "In updateAttribute   ${myattribute} was set to ${value}${unit ?: ''}"
    if (device.currentValue(attribute) != value && (settings.infoLogging)) {
        log.info descriptionText
    }
    sendEvent(name: myattribute, value: value, unit: unit, type: type, descriptionText: descriptionText)
    if ((myattribute == "amperage") && (value == 0)) 
        {
            sendEvent(name: "powerFactor", unit: "", value: 0.0, type: type, descriptionText: "set to zero if current is zero")
            sendEvent(name: "power", unit: "W", value: 0, type: type, descriptionText: "set to zero if current is zero")
        }
}

/**
 * Update the power factor calculation
 */
private void updatePowerFactor() {
    final BigDecimal rmsVoltage = device.currentValue('voltage') as BigDecimal
    final BigDecimal rmsCurrent = device.currentValue('amperage') as BigDecimal
    final BigDecimal activePower = device.currentValue('power') as BigDecimal
    if (rmsVoltage && rmsCurrent && activePower) {
        BigDecimal powerFactor = calculatePowerFactor(rmsVoltage, rmsCurrent, activePower)
        if (powerFactor < -1) { powerFactor = -1 } // power factor can't be less than -1
        if (powerFactor > 1) { powerFactor = 1 } // power factor can't be greater than 1
        powerFactor = powerFactor.setScale(1, RoundingMode.HALF_UP)
        sendEvent(name: "powerFactor", unit: "", value:powerFactor, type: null, descriptionText: "powerfactor attribute updated")
    }
}

// innr SP242
//@Field static Map constantsMultDiv = [1536:1, 771:42, 1541:1, 1540:1, 768:0, 1539:1000, 1538:1, 1537:1]  // attribute:value - attributeInteger in Metering_Cluster & values specific to this device (read earlier)
//@Field Map readCconstantsMultDiv = [:]


// Zigbee Attribute IDs
@Field static final int AC_CURRENT_DIVISOR_ID = 0x0603  //decimal 1539  divisor is 1000 so measuring mA and divide by 1000 to present Amps
@Field static final int AC_CURRENT_MULTIPLIER_ID = 0x0602
@Field static final int AC_FREQUENCY_ID = 0x0300
@Field static final int AC_POWER_DIVISOR_ID = 0x0605
@Field static final int AC_POWER_MULTIPLIER_ID = 0x0604
@Field static final int AC_VOLTAGE_DIVISOR_ID = 0x0601
@Field static final int AC_VOLTAGE_MULTIPLIER_ID = 0x0600
@Field static final int ACTIVE_POWER_ID = 0x050B
@Field static final int ATTRIBUTE_READING_INFO_SET = 0x0000
@Field static final int FIRMWARE_VERSION_ID = 0x4000
@Field static final int PING_ATTR_ID = 0x01
@Field static final int POWER_ON_OFF_ID = 0x0000
@Field static final int POWER_RESTORE_ID = 0x4003
@Field static final int RMS_CURRENT_ID = 0x0508
@Field static final int RMS_VOLTAGE_ID = 0x0505
@Field static final int METERING_UNIT_OF_MEASURE_ID = 0x0300        // UnitofMeasure - enum8 - 0x00 to 0xFF - readable def0x00 mandatory Table 10-71 - value 00 is kWh
@Field static final int METERING_DIVISOR_ID = 0x0302                // Divisor - uint24 - 000000 to FFFFFF - readable - OPTIONAL // not available on this device
@Field static final int METERING_SUMMATION_FORMATTING_ID = 0x0303   // Summation Formating - map8 - 00 to FF - readable - mandatory

/**
Table 10-72. UnitofMeasure Attribute Enumerations
0x00 kWh (Kilowatt Hours) & kW (Kilowatts) in pure binary format
0x80 kWh (Kilowatt Hours) & kW (Kilowatts) in BCD format

10.4.2.2.4.3 Divisor Attribute
Divisor provides a value to divide the results of applying the Multiplier Attribute against a raw or uncom-
pensated sensor count of Energy, Gas, or Water being measured by the metering device. If present, this
attribute must be applied against all summation, consumption and demand values to derive the delivered
and received values expressed in the unit of measure specified.

10.4.2.2.4.4 SummationFormatting Attribute
Bits 0 to 2: Number of Digits to the right of the Decimal Point.
Bits 3 to 6: Number of Digits to the left of the Decimal Point.
Bit 7: If set, suppress leading zeros.
**/

@Field static final Map PowerRestoreOpts = [
    defaultValue: 0xFF,
    options: [ 0x00: 'Off', 0x01: 'On', 0xFF: 'Last State' ]
]

@Field static final Map HealthCheckIntervalOpts = [
    defaultValue: 10,
    options: [ 10: 'Every 10 Mins', 15: 'Every 15 Mins', 30: 'Every 30 Mins', 45: 'Every 45 Mins', 59: 'Every Hour', 00: 'Disabled' ]
]

// Command timeout before setting healthState to offline
@Field static final int COMMAND_TIMEOUT = 10

// Delay in between zigbee commands
@Field static final int DELAY_MS = 300

@Field static final Map<Integer, String> ZigbeeStatusEnum = [
    0x00: 'Success',
    0x01: 'Failure',
    0x02: 'Not Authorized',
    0x80: 'Malformed Command',
    0x81: 'Unsupported COMMAND',
    0x85: 'Invalid Field',
    0x86: 'Unsupported Attribute',
    0x87: 'Invalid Value',
    0x88: 'Read Only',
    0x89: 'Insufficient Space',
    0x8A: 'Duplicate Exists',
    0x8B: 'Not Found',
    0x8C: 'Unreportable Attribute',
    0x8D: 'Invalid Data Type',
    0x8E: 'Invalid Selector',
    0x94: 'Time out',
    0x9A: 'Notification Pending',
    0xC3: 'Unsupported Cluster'
]

@Field static final Map<Integer, String> ZdoClusterEnum = [
    0x0013: 'Device announce',
    0x8004: 'Simple Descriptor Response',
    0x8005: 'Active Endpoints Response',
    0x801D: 'Extended Simple Descriptor Response',
    0x801E: 'Extended Active Endpoint Response',
    0x8021: 'Bind Response',
    0x8022: 'Unbind Response',
    0x8023: 'Bind Register Response',
]

@Field static final Map<Integer, String> ZigbeeGeneralCommandEnum = [
    0x00: 'Read Attributes',
    0x01: 'Read Attributes Response',
    0x02: 'Write Attributes',
    0x03: 'Write Attributes Undivided',
    0x04: 'Write Attributes Response',
    0x05: 'Write Attributes No Response',
    0x06: 'Configure Reporting',
    0x07: 'Configure Reporting Response',
    0x08: 'Read Reporting Configuration',
    0x09: 'Read Reporting Configuration Response',
    0x0A: 'Report Attributes',
    0x0B: 'Default Response',
    0x0C: 'Discover Attributes',
    0x0D: 'Discover Attributes Response',
    0x0E: 'Read Attributes Structured',
    0x0F: 'Write Attributes Structured',
    0x10: 'Write Attributes Structured Response',
    0x11: 'Discover Commands Received',
    0x12: 'Discover Commands Received Response',
    0x13: 'Discover Commands Generated',
    0x14: 'Discover Commands Generated Response',
    0x15: 'Discover Attributes Extended',
    0x16: 'Discover Attributes Extended Response'
]
